import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.56.0";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Noto Sans Arabic font as base64 (subset for common Arabic characters)
// This is a minimal subset - for production, consider using a CDN
const ARABIC_FONT_URL = 'https://fonts.gstatic.com/s/notosansarabic/v18/nwpxtLGrOAZMl5nJ_wfgRg3DrWFZWsnVBJ_sS6tlqHHFlhQ5l3sQWIHPqzCfyGyvvnCBFQLaig.ttf';

// Content limits (safety caps)
const CONTENT_LIMITS = {
  maxSections: 12,
  maxTableRows: 50
};

interface DocumentSection {
  heading: string;
  content?: string;
  table?: {
    headers: string[];
    rows: string[][];
  };
}

interface DocumentRequest {
  type: 'pdf' | 'excel';
  language: 'en' | 'ar' | 'fr';
  title: string;
  sections: DocumentSection[];
  userId?: string;
}

// Apply content limits to prevent abuse
function applyContentLimits(sections: DocumentSection[]): DocumentSection[] {
  // Limit number of sections
  const limitedSections = sections.slice(0, CONTENT_LIMITS.maxSections);
  
  // Limit table rows in each section
  return limitedSections.map(section => {
    if (section.table?.rows) {
      return {
        ...section,
        table: {
          headers: section.table.headers,
          rows: section.table.rows.slice(0, CONTENT_LIMITS.maxTableRows)
        }
      };
    }
    return section;
  });
}

// Detect language from content if not specified
function detectLanguage(content: string): 'en' | 'ar' | 'fr' {
  // Arabic detection
  if (/[\u0600-\u06FF]/.test(content)) return 'ar';
  // French detection (common French words/accents)
  if (/[àâäéèêëïîôùûüÿœæç]/i.test(content) || 
      /\b(le|la|les|un|une|des|et|ou|mais|donc|car|ni|or|que|qui|quoi)\b/i.test(content)) return 'fr';
  return 'en';
}

// Format date based on language
function formatDate(date: Date, language: string): string {
  const options: Intl.DateTimeFormatOptions = { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  };
  
  const locales: Record<string, string> = {
    ar: 'ar-SA',
    fr: 'fr-FR',
    en: 'en-US'
  };
  
  return date.toLocaleDateString(locales[language] || 'en-US', options);
}

// Get branded footer text
function getFooterText(language: string): string {
  const footers: Record<string, string> = {
    ar: 'تم إنشاؤه بواسطة AYN',
    fr: 'Généré par AYN',
    en: 'Generated by AYN'
  };
  return footers[language] || footers.en;
}

// Generate PDF using jsPDF
async function generatePDF(data: DocumentRequest): Promise<Uint8Array> {
  // Dynamic import of jsPDF
  const { jsPDF } = await import("https://esm.sh/jspdf@2.5.1");
  
  const isRTL = data.language === 'ar';
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });
  
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - (2 * margin);
  let y = 0;
  
  // Load Arabic font if needed
  if (isRTL) {
    try {
      const fontResponse = await fetch(ARABIC_FONT_URL);
      if (fontResponse.ok) {
        const fontBuffer = await fontResponse.arrayBuffer();
        const fontBase64 = btoa(String.fromCharCode(...new Uint8Array(fontBuffer)));
        doc.addFileToVFS('NotoSansArabic.ttf', fontBase64);
        doc.addFont('NotoSansArabic.ttf', 'NotoSansArabic', 'normal');
        doc.setFont('NotoSansArabic');
      }
    } catch (e) {
      console.warn('[generate-document] Failed to load Arabic font, using default:', e);
    }
  }
  
  // ===== HEADER SECTION =====
  // Dark gradient header background
  doc.setFillColor(26, 26, 46); // #1a1a2e
  doc.rect(0, 0, pageWidth, 45, 'F');
  
  // Lighter accent line at bottom of header
  doc.setFillColor(22, 33, 62); // #16213e
  doc.rect(0, 40, pageWidth, 5, 'F');
  
  // AYN Logo/Brand text
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(24);
  if (isRTL) {
    doc.text('AYN', pageWidth - margin, 20, { align: 'right' });
  } else {
    doc.text('AYN', margin, 20);
  }
  
  // Title
  doc.setFontSize(16);
  const titleMaxWidth = pageWidth - 80;
  const titleLines = doc.splitTextToSize(data.title, titleMaxWidth);
  if (isRTL) {
    doc.text(titleLines[0] || data.title, pageWidth - margin, 32, { align: 'right' });
  } else {
    doc.text(titleLines[0] || data.title, margin, 32);
  }
  
  // Date
  doc.setFontSize(10);
  doc.setTextColor(180, 180, 200);
  const dateStr = formatDate(new Date(), data.language);
  if (isRTL) {
    doc.text(dateStr, margin, 32, { align: 'left' });
  } else {
    doc.text(dateStr, pageWidth - margin, 32, { align: 'right' });
  }
  
  y = 60; // Start content after header
  
  // ===== CONTENT SECTIONS =====
  doc.setTextColor(33, 33, 33);
  
  for (const section of data.sections) {
    // Check if we need a new page
    if (y > pageHeight - 50) {
      addFooter(doc, pageWidth, pageHeight, margin, data.language, isRTL);
      doc.addPage();
      y = 30;
    }
    
    // Section heading with accent bar
    doc.setFillColor(78, 78, 120); // Purple accent
    if (isRTL) {
      doc.rect(pageWidth - margin - 3, y - 4, 3, 10, 'F');
    } else {
      doc.rect(margin, y - 4, 3, 10, 'F');
    }
    
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.setFont(isRTL ? 'NotoSansArabic' : 'helvetica', 'bold');
    
    if (isRTL) {
      doc.text(section.heading, pageWidth - margin - 8, y, { align: 'right' });
    } else {
      doc.text(section.heading, margin + 8, y);
    }
    
    y += 10;
    
    // Section content
    if (section.content) {
      doc.setFontSize(11);
      doc.setTextColor(60, 60, 60);
      doc.setFont(isRTL ? 'NotoSansArabic' : 'helvetica', 'normal');
      
      const lines = doc.splitTextToSize(section.content, contentWidth - 10);
      for (const line of lines) {
        if (y > pageHeight - 40) {
          addFooter(doc, pageWidth, pageHeight, margin, data.language, isRTL);
          doc.addPage();
          y = 30;
        }
        if (isRTL) {
          doc.text(line, pageWidth - margin - 5, y, { align: 'right' });
        } else {
          doc.text(line, margin + 5, y);
        }
        y += 6;
      }
      y += 5;
    }
    
    // Section table
    if (section.table && section.table.headers && section.table.rows) {
      const table = section.table;
      const colCount = table.headers.length;
      const colWidth = (contentWidth - 10) / colCount;
      const startX = margin + 5;
      
      // For RTL, reverse columns
      const headers = isRTL ? [...table.headers].reverse() : table.headers;
      const rows = isRTL ? table.rows.map(row => [...row].reverse()) : table.rows;
      
      // Table header
      doc.setFillColor(240, 240, 245);
      doc.rect(startX, y - 4, contentWidth - 10, 10, 'F');
      
      doc.setFontSize(10);
      doc.setTextColor(33, 33, 33);
      doc.setFont(isRTL ? 'NotoSansArabic' : 'helvetica', 'bold');
      
      headers.forEach((header, i) => {
        const x = startX + (i * colWidth) + (colWidth / 2);
        doc.text(header, x, y + 2, { align: 'center' });
      });
      
      y += 10;
      
      // Table rows
      doc.setFont(isRTL ? 'NotoSansArabic' : 'helvetica', 'normal');
      rows.forEach((row, rowIndex) => {
        if (y > pageHeight - 40) {
          addFooter(doc, pageWidth, pageHeight, margin, data.language, isRTL);
          doc.addPage();
          y = 30;
        }
        
        // Alternating row colors
        if (rowIndex % 2 === 1) {
          doc.setFillColor(248, 248, 252);
          doc.rect(startX, y - 4, contentWidth - 10, 8, 'F');
        }
        
        doc.setTextColor(60, 60, 60);
        row.forEach((cell, i) => {
          const x = startX + (i * colWidth) + (colWidth / 2);
          doc.text(String(cell || ''), x, y, { align: 'center' });
        });
        
        y += 8;
      });
      
      // Table border
      doc.setDrawColor(200, 200, 210);
      doc.rect(startX, y - 8 - (rows.length * 8) - 10, contentWidth - 10, (rows.length + 1) * 8 + 10);
      
      y += 10;
    }
    
    y += 8; // Space between sections
  }
  
  // Add final footer
  addFooter(doc, pageWidth, pageHeight, margin, data.language, isRTL);
  
  return doc.output('arraybuffer') as unknown as Uint8Array;
}

function addFooter(
  doc: any, 
  pageWidth: number, 
  pageHeight: number, 
  margin: number, 
  language: string,
  isRTL: boolean
): void {
  const footerY = pageHeight - 15;
  
  // Footer line
  doc.setDrawColor(200, 200, 210);
  doc.line(margin, footerY - 5, pageWidth - margin, footerY - 5);
  
  // Footer text
  doc.setFontSize(9);
  doc.setTextColor(130, 130, 140);
  
  const footerText = getFooterText(language);
  const pageNum = `${doc.getCurrentPageInfo().pageNumber}`;
  
  if (isRTL) {
    doc.text(pageNum, margin, footerY);
    doc.text(footerText, pageWidth - margin, footerY, { align: 'right' });
  } else {
    doc.text(footerText, margin, footerY);
    doc.text(pageNum, pageWidth - margin, footerY, { align: 'right' });
  }
}

// Generate Excel using SheetJS
async function generateExcel(data: DocumentRequest): Promise<Uint8Array> {
  const XLSX = await import("https://esm.sh/xlsx@0.20.1");
  
  const isRTL = data.language === 'ar';
  const wb = XLSX.utils.book_new();
  
  // Create main data sheet
  const allRows: (string | number)[][] = [];
  
  // Add title row
  allRows.push([data.title]);
  allRows.push([formatDate(new Date(), data.language)]);
  allRows.push([]); // Empty row
  
  for (const section of data.sections) {
    // Section heading
    allRows.push([section.heading]);
    
    // Section content as wrapped text
    if (section.content) {
      allRows.push([section.content]);
    }
    
    // Section table
    if (section.table && section.table.headers) {
      const headers = isRTL ? [...section.table.headers].reverse() : section.table.headers;
      allRows.push(headers);
      
      for (const row of section.table.rows || []) {
        const rowData = isRTL ? [...row].reverse() : row;
        allRows.push(rowData);
      }
    }
    
    allRows.push([]); // Empty row between sections
  }
  
  // Add footer
  allRows.push([getFooterText(data.language)]);
  
  const ws = XLSX.utils.aoa_to_sheet(allRows);
  
  // Set RTL for Arabic
  if (isRTL) {
    ws['!RTL'] = true;
  }
  
  // Auto-size columns (approximate)
  const colWidths = allRows.reduce((acc, row) => {
    row.forEach((cell, i) => {
      const len = String(cell || '').length;
      acc[i] = Math.max(acc[i] || 10, Math.min(len + 2, 50));
    });
    return acc;
  }, [] as number[]);
  
  ws['!cols'] = colWidths.map(w => ({ wch: w }));
  
  XLSX.utils.book_append_sheet(wb, ws, data.language === 'ar' ? 'التقرير' : 
                                       data.language === 'fr' ? 'Rapport' : 'Report');
  
  const buffer = XLSX.write(wb, { type: 'array', bookType: 'xlsx' });
  return new Uint8Array(buffer);
}

// Upload to Supabase Storage
async function uploadToStorage(
  supabase: ReturnType<typeof createClient>,
  data: Uint8Array,
  filename: string,
  contentType: string,
  userId?: string
): Promise<string> {
  const bucket = 'documents';
  const path = `${userId || 'anonymous'}/${filename}`;
  
  // Ensure bucket exists
  const { data: buckets } = await supabase.storage.listBuckets();
  const bucketExists = buckets?.some(b => b.name === bucket);
  
  if (!bucketExists) {
    await supabase.storage.createBucket(bucket, {
      public: false,
      fileSizeLimit: 10485760 // 10MB
    });
  }
  
  // Upload file
  const { error: uploadError } = await supabase.storage
    .from(bucket)
    .upload(path, data, {
      contentType,
      upsert: true
    });
  
  if (uploadError) {
    console.error('[generate-document] Upload error:', uploadError);
    throw new Error(`Upload failed: ${uploadError.message}`);
  }
  
  // Create signed URL (7 days)
  const { data: signedData, error: signError } = await supabase.storage
    .from(bucket)
    .createSignedUrl(path, 7 * 24 * 60 * 60); // 7 days in seconds
  
  if (signError || !signedData?.signedUrl) {
    throw new Error(`Failed to create signed URL: ${signError?.message}`);
  }
  
  return signedData.signedUrl;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const body: DocumentRequest = await req.json();
    
    // Validate request
    if (!body.type || !body.title || !body.sections) {
      return new Response(JSON.stringify({ 
        error: 'Missing required fields: type, title, sections' 
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
    
    // Auto-detect language if not specified
    const language = body.language || detectLanguage(body.title + ' ' + 
      body.sections.map(s => s.heading + (s.content || '')).join(' '));
    
    // Apply content limits (safety caps)
    const limitedSections = applyContentLimits(body.sections);
    console.log(`[generate-document] Applied limits: ${body.sections.length} → ${limitedSections.length} sections`);
    
    console.log(`[generate-document] Creating ${body.type.toUpperCase()} in ${language}: ${body.title}`);
    
    let fileData: Uint8Array;
    let filename: string;
    let contentType: string;
    
    const timestamp = Date.now();
    const safeTitle = body.title.replace(/[^a-zA-Z0-9\u0600-\u06FF]/g, '_').substring(0, 50);
    
    if (body.type === 'pdf') {
      fileData = await generatePDF({ ...body, language, sections: limitedSections });
      filename = `${safeTitle}_${timestamp}.pdf`;
      contentType = 'application/pdf';
    } else if (body.type === 'excel') {
      fileData = await generateExcel({ ...body, language, sections: limitedSections });
      filename = `${safeTitle}_${timestamp}.xlsx`;
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    } else {
      return new Response(JSON.stringify({ 
        error: 'Invalid type. Must be "pdf" or "excel"' 
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
    
    // Upload to storage
    const downloadUrl = await uploadToStorage(
      supabase,
      fileData,
      filename,
      contentType,
      body.userId
    );
    
    console.log(`[generate-document] Document created: ${filename}`);
    
    return new Response(JSON.stringify({
      success: true,
      downloadUrl,
      filename,
      type: body.type,
      language
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('[generate-document] Error:', error);
    
    return new Response(JSON.stringify({
      error: error instanceof Error ? error.message : 'Document generation failed',
      success: false
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});
